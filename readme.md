参考了往年的复习笔记"2020计原复习笔记"

# data

## 编码

ASCII: 7位二进制编码 （扩展ASCII是8位的），占用**一个字节**

UNICODE：兼容ASCII，**2个字节**（16位，65536个字符）

UTF-8：**变长**字符编码，字符长度由首字节确定（0ddd表示1字节，110ddd表示2字节，1110ddd表示3字节（几个1表示几个字节，除了1个字节的）），之所以不用10ddd开头是因为首字节之外的字节都用10ddd 开头，可自同步（字符的边界明确，丢失一个字节可以发现）。



点阵字体：本质是单色位图（放大后不清晰 ）

矢量字体  



## 校验

验算校验位的合法性即可检错/纠错



循环冗余校验码： 串行数据传输  

下面两个都是并行的

### 奇偶校验

奇校验：奇校验位 使得数据码和校验位异或起来为1

偶校验：偶校验位 使得数据码和校验位异或起来为0



### 海明码

k位数据，r位校验位

纠1bit错：$2^r\ge k+r+1$，就是用2r个编码分别表示k个数据位， r个校验位中哪一位出错， 都不错 （这样比网原里面的解释好理解多了）

检2bit错：$2^{r-1}\ge k+r$，r-1为校验码为出错位编码，剩下一位来判断是1位出错还是2位出错（...这里怎么判断没错）



至于如何计算校验位：k=3,r=4： D3 D2 D1 P4 P3 P2 P1

把校验位排布在2的幂次方位上（从1开始,1,2,4,8），数据位按顺序排剩下的位置: 

```
P1 P2 D1 P3 D2 D3 P4 (因为这里校验位其实多了一个，数据位不够，所以P4视作总校验位直接放在最后面)
1  2  3  4  5  6  7
```

然后对于D1: 3 = 1 + 2，因此是P1 P2来校验D1。

D2: 5 = 1 + 4。

D3: 6 = 2 + 4

因此$P1 = D1\oplus D2,\ P2 = D1\oplus D3 \dots$

总校验位把所有校验位数据位都异或起来P4 = P3 ⊕ P2 ⊕ P1 ⊕ D3 ⊕ D2 ⊕ D1  

（其实只需关心为1的数据位）



## 杂

0的原码和反码都有两种（+0 -0），但补码只有一种

不能说负数的原码、反码、补码均不同，例如$-2^{30}$，原码和补码都是$11000...00$



## 浮点数

浮点数加法不满足结合律



回顾一下浮点数表示法： s  exp  frac

M 尾数  E 阶码

-> $(-1)^sM2^E$，$M=1.\{frac\}$ 

对规格化浮点数，$E=exp - bias (bias=2^{k-1}-1,k为exp域的宽度)$ ，

对非规格化浮点数（exp全0），$E=1-bias$



### 浮点数加减乘除

加减：

$X=M_X2^{E_X}, Y=M_Y2^{E_Y}$

求阶差：$\Delta E = E_X-E_Y$

阶码小的数的尾数右移$\Delta E$位，其阶码改成大的阶码值



乘除：

阶码直接加减，尾数进行乘除



# ALU

## 乘法

原码乘法：

实现方法一（会浪费加法器一半的位数）：每位依次考虑（竖式）。看乘数是1 or 0。1：被乘数左移一位。然后求和。

因此可以考虑实现方法二：竖式乘法中从上往下乘出来的每个结果，依次放在最高的32位，每次右移然后只需最高32位进行加法。

实现方法三是节省空间，把乘数放在低32位，算完乘数的一位后右移对乘数没有影响。



部分积：（乘数的某一位和被乘数相乘的结果）



补码乘法

1：转成原码绝对值

2：布斯乘法：核心在于补码直接乘（模意义下的乘，因此没有问题），后续可以进行拆解简化运算

补码的定义：注意是个模$2^{n+1}$剩余系
$$
[x]_补=\begin{cases}
x \qquad  0\le x \lt2^n\\
2^{n+1} +x \qquad -2^n \le x \le 0 (\mod 2^{n+1})
\end{cases}  
$$
$[x]_补 = x \mod 2^{n+1}$

$[x]_补 = x_{n-1}x_{n-2}...x_0$

看成 $x = -2^{n-1}x_{n-1} + \sum_{i=0}^{n-2}x_i2^i$
$$
[x*y]_补= [x]_{补}*y\\
=[x]_补*(-2^{n-1}y_{n-1}+\sum_{i=0}^{n-2}y_i2^i)\\
=[x]_补*(2^{n-1}(y_{n-2}-y_{n-1}+2^{n-2}(y_{n-3}-y_{n-2}))+2^0(y_{-1}-y_0))\\
=[x]_补*\sum_{i=0}^{n-1}2^i(y_{i-1}-y_i) \qquad(y_{-1}=0)
$$
乘的时候根据y的两位取值($y_i \ y_{i-1}$)来计算

00: +0

01: +被乘数

10: -被乘数

11: +0

（注意-1位是0）



被乘数 Multiplicand

乘数 Multiplier



X * Y

比如ppt的例子， 2 * (-5)，两个五位二进制数，结果是10位

先把乘数填进低五位：0000011011 | 0(这是初始部分积，目前的低五位其实对答案没有影响，会逐渐右移而消失，把-5放到低五位是为了复用空间)

然后X=被乘数=2。依次考虑**乘数**，也就是5 (11011 | 0， 最后那个是附加位)

-5的最低位1 | 0： -X  (在高五位进行-X，因为之后会不断右移)， 变成 11110 11011 | 0

然后右移（每回合都要右移，最高位补上符号位）： 11111 01101 | 1

-5的1位 11： +0， 右移，以此类推，最后的部分积就是答案（10位二进制数，补码形式）



这里用到了原码乘法三的优化（只在高五位进行加法，低五位存储成熟以节省空间）



## 除法

原码除法

加减交替除法： X / Y

最开始默认先减一个Y，然后不断看（商从低到高标记）：

- 上次余数R>0：商1，下次求商用R=2R-Y

- 上次余数R<0：商0，下次求商用R=2R+Y



也就是： $-Y \Rightarrow 左移 \Rightarrow 根据上次加减的结果选择+Y/-Y \Rightarrow 左移 \dots$

（上次商负数就+Y，商正数就-Y）

(-Y可以变为加-Y的补码)

注意缩放的问题：$X\div Y=Q \dots R$， $\frac{X}{10} = \frac{Y}{10}*Q+\frac{R}{10}$

每步写的余数是经过缩小的，还有注意商是从哪一位开始。可以用恢复余数法来先算出答案（X减一下Y，小于0就撤回，将X左移。或者直接竖式除法）



补码除法我可以直接转原码再看一下符号？



# Instruction, RISC-V

controller控制器就是datapath中最底下为各部件提供控制信号的玩意。

寻址方式：



riscv 寻址方式：

- 立即数寻址 n  （直接给出这个操作数n）
- 寄存器寻址 reg[n]

其他：

- 直接寻址 mem[n]
- 间接寻址 mem[mem[n]]
- 寄存器间接寻址：mem[reg[n]]
- 相对寻址 PC+offset
- 变址寻址 mem[reg[n] + offset]
- 基址寻址 mem[regc + offset] (regc是基址寄存器)
- 堆栈寻址



sll: shift left logical (双操作数)

sra: shift right arithmetic 



slt: Set Less Than   (reg[src1] < reg[src2]则set dst=1)



伪指令：move， li(load immediate), la(load address)

伪指令的定义是汇编语言程序员可以使用的指令（包括了伪指令和正常的硬件指令），因此硬件指令被包含于伪指令



lb/sb使用的是最低的字节 ，高24位会被忽略



立即数有的有20位，有的有12位。像I型指令，立即数都是12位的。lui可以装入20位立即数到最高的20位。



# 单周期、多周期、流水线

单周期CPI=1

多周期CPI$\approx$4， 因为大多数指令没有MEM阶段

流水线 尖峰CPI=1  （五条指令重叠的时候，CPI为1。同时只执行一个IF阶段时，CPI为5的样子）



IF、ID、EX、MEM、WB

控制器的组成：PC、IR（指令寄存器）、指令执行步骤标记线路（→组合逻辑控制器，即硬连线控
制器，用Timer维护一个状态机序号） or 控制信号产生线路（微程序控制器）   



哈佛结构：分离 IM, DM （指令存储器和数据存储器）

普林斯顿结构（就是冯诺依曼结构）：IM和DM合并在一起



## 结构冲突 数据冲突

结构冲突：寄存器结构冲突（ID&WB）、内存结构冲突（IF&MEM）。  同时读写的问题

寄存器结构冲突：可以通过不同的端口解决，2 read ports & write port

内存结构冲突：stall（气泡）、用哈佛结构分离IM DM



数据冲突：

```assembly
add t0, t1, t2
sub t4, t0, t3
```

写后读冲突（RAW），上条指令WB时才写回，但下一条两条指令的ID就需要使用了（此时上一条指令至多执行到EX or MEM）

使用数据前传（数据旁路）：EX, MEM的输出数据前传到EX阶段的输入



写后写冲突和读后写冲突均不会在RISCV中发生。



装入使用冲突（load之后立即使用）：必须插入气泡，然后同样使用数据前传（这里是MEM的输出传到EX的输入）

```
IF ID EX MEM WB
   IF ID BUB EX MEM WB
      IF BUB ID EX  MEM WB
```

这种等价于nop指令。

汇编器静态调度 ：汇编时调整指令顺序，避免出现load之后马上使用的情况

硬件动态调度：指令乱序流出，可能产生异常处理不够精确的问题



## 控制冲突

控制冲突：分支指令 

EX阶段才生成转移到的newPC，需要1个周期传入PC，1个周期传入IF，需要暂停两拍

```
IF ID   EX  MEM   WB
   IF stall stall IF ID EX MEM WB
      				 IF ID EX  MEM WB
```

可以改进一下，增加目标地址加法器和寄存器比较器，在ID阶段就确定需要的信息 PC=MUX(NewPC, PC+4)，这样只要暂停一拍



## 分支预测

预测分支转移”失败“还是”成功“

预测错误后， 要清除已执行指令的影响  。



静态预测（可用BTB也可不用）：一直预测不跳转或者一直预测跳转



动态预测：

分支目标缓冲技术（Branch Target Buffer， BTB），一个缓冲区用于预测分支转移是否成功，缓冲区保存：

1. *分支转移成功的*  分支指令的地址 （key）
2. 分支目标地址  (value)

用分支指令的地址作为标志来查找（如果上次分支转移成功了， 那么预测下一次分支转移也成功  ）

减少BTB容量：只保存key类型为B或J的PC值。



增加BHT位：Branch History Table。预测历史。1位 or 2位

对于2位的，要连续预测错两次才会改变预测方向。（我一开始预测跳，必须连续错两次才会改变预测方向，变成预测不跳，且记录当前连续错误次数为0）



# 异常

异常中断：

来自CPU：异常

来自外部设备：中断



异常处理的实现：

保存现场

- mepc（发生异常指令的地址）
- 当前的状态等（状态寄存器）  

转异常处理程序（中断服务） 。 异常原因：mcause

处理完成后， 返回主程序执行  



# DRAM

存储器系统设计目标 ： 高速度、大容量、低成本、高可靠性  

局部性原理 ：

时间：在一小段时间内， 最近被访问过的程序和数据很可能再次被访问  

空间：在空间上这些被访问的程序和数据往往集中在一小片存储区 

顺序：在访问顺序上， 指令顺序执行比转移执行的可能性大(大约5:1 )  



层次设计存储应满足的原则：

一致性原则、包含性原则  



主存是DRAM，L1 ~ L3 cache是SRAM



DRAM动态存储器存储原理：1个晶体管+1个电容  

特点：

- 破坏性读出（读出时被强制清零 ，电容放完电就没数据了）
- 需定时刷新（电容会漏电，所以要重新写），又分为几种刷新和分散刷新
- 快速分页组织



# cache 静态存储器和高速缓冲存储器

## SRAM：

使用D触发器（D触发器在上升沿或者高电平的时候，根据输入D的取值，设置Q=D，实现存储功能）

不会破坏性读出也不需要更新

|            | SRAM   | DRAM     |
| ---------- | ------ | -------- |
| 送行列地址 | 同时送 | 分两次送 |
| 集成度     | 低     | 高       |
| 发热量     | 大     | 小       |
| 存储信息   | 触发器 | 电容     |



## Cache

主存和cpu之间的存储器，用SRAM实现

高速：和CPU的运行速度基本匹配

透明：完全硬件管理，对程序员透明



工作原理根据时间和空间局部性



平均访问时间 = 命中率 × 命中时间 + (1-命中率) × 缺失时间  （缺失时间包括访问cache和缺失之后访问主存的时间）



cache有很多组，每个组有一些路，每个路里面是一个块，一个块存储若干个字节

tag：是用来比较是否相等的

block offset： 每个块内部的offset



全相联：1组  E ways（E路）

PC只被划分为标记位和块内地址，即tag | block offset  

【计算】假设按字节寻址，则存储单元大小为1 byte

- 主存4GB => 地址存储单元个数为4G，32位，则pc总位数是32
- Cache大小4KB，块大小4B => 块个数=4KB / 4B = 1K（10位），又set为0位，则E路的E=10
- 块大小4B => 块内地址有4个，block offset占2位，则tag位数=32-2=30

特点：

- 主存的字块可以和Cache的任何字块对应，利用率高，方式灵活（**不会出现conflict miss**！直接映射或多路组相联才会出现）
- tag位比较长，使用比较电路成本高  



直接映射：E = 1 ways， 一个组只有一个块

PC被划分为标记位、组索引和块内地址，即tag | set index | block offset  

【计算】假设按字节寻址，则存储单元大小为1 byte

- 主存4GB => 地址存储单元个数为4G，32位，则pc总位数是32
- Cache大小4KB，块大小4B => 块个数=4KB / 4B = 1K（10位），又组内只有一路，则组数
  =10，即set index占10位
- 块大小4B => 块内地址有4个，block offset占2位，则tag位数=32-10-2=20  



多路组相联 类似于直接映射（定位到组之后，用tag去查找是哪一路的）



容量为N、 采用直接映射方式Cache的缺失率 和 容量为N/2、 采用2路组相联映射方式Cache的缺失率 相当  （后者容量小一些，但采用了2路组相联，所以缺失率反而相当）。

块大小取一个适中的值，缺失率最低。

块大小增大，导致缺失损失增大（装入数据块的时间增大）



保持层次一致性 ：

写直达（write through）：强一致性  （串口一定要采用这种方式  ）

拖后写（write back）：弱一致性，替换cache时再写回主存  



一致性保证策略（MESI） ：缓存行的状态转换（M修改态，E独占态，S共享态，I无效态）。有个状态转移图  



缺失的原因：

必然缺失 （都会发生 ，比如开机）

容量缺失（全相联经常发生  ）

冲突缺失（直接映射经常发生  ）

无效缺失



块替换策略（一个组有很多位置才需要替换策略，全相联和N路组相联这种）  LRU、FIFO、RAND  



Cache接入系统的体系结构  ：

侧接法：接到总线上  （总线占用率高）  

隔断法：CPU - Cache ----总线---- 其他I/O设备  



# 虚存

虚存：由操作系统管理，进行主存和外存数据交换。他把主存看作磁盘的高速缓存



## 页表

这些东西温习一下习题就知道了

PTE：page table entry



TLB：也是一种缓存

TLB缺失将导致：流水线停止，通知OS，OS读页表，将页表项写回TLB，返回用户态，重新访问。  

减少缺失的方法：多路组相连、提高TLB容量。  



VA总共n位，PA总共m位

VPO=PPO： p位， page size = $2^p$

VA的剩余n-p位就是VPN的，PA的剩余m-p位就是PPN的

页表实现将VPN->PPN



> VPN：
>
> TLBT  TLBI   VPO
>
> TLBT  TLBI组成VPN
>
> 
>
> PPN：
>
> PPN PPO 或者
>
> CT  CI  CO

TLBI 由 组数决定（index范围）

CO（Byte offset within cache line）由块（cache line）大小决定，CI由 cache那边的index决定。

TLB -> 页表 -> cache



# 外存储器

外存是非易失性存储，包括磁盘（disk）、磁带、光盘、SSD。  断电不会丢失

是串行访问 （而不是RAM的随机访问）



## 磁盘Disk

1. 寻道：找到同心圆，即磁道track
2. 寻找扇区（rotate）：转到要读的扇区sector
3. 数据传输io：时间=数据大小/传输速度
4. 还有磁盘控制器延迟



减小开销：相邻扇区、放于同一cylinder



可靠性 ：设备不出错。  

可用性 ：系统正常运行。  

可用性的提高可能带来可靠性的降低 （增加硬件冗余）



## RAID

廉价磁盘的冗余阵列（Redundant Arrays of Inexpensive Disks）  

建议看ppt复习

RAID0： 若干个disk拥有很多个strip，没有真正的冗余

RAID1：简单的copy，镜像。写要同时写两边

RAID2：类似于海明码校验

RAID3：校验盘（byte-level striping）

RAID4：校验盘（block-level striping）

RAID5：将校验位循环均匀分布到所有的驱动器上

RAID6：二维校验



## SSD

固态硬盘（Solid State Drives）：由控制单元、存储单元（FLASH+DRAM芯片）组成  

控制单元：FTL完成上层逻辑地址→底层物理地址的转换、磨损均衡。  

存储单元：组织结构从大到小为：package-die-plane-block-page 。

擦除按block（有限次擦除），读写按页进行



按照每个存储单元能够存储的位数分为SLC，MLC， TLC， QLC   （从小到大，1-4）

SLC擦除次数最大



写入的时候不会在原来的page中写入， 会在一个新的页面（可以在同一个块， 也可以在不同的块，可能不同的plane， 甚至不同的die上面）  

<img src="pics\SSD.png" alt="SSD" style="zoom:60%;" />



SSD读写是几百MB/s级别的带宽，擦除的时间是毫秒级别的



# RISC-V的系统模式

内核态即监管者模式（supervisor），操作系统这一层面

机器态（M） 内核态（S） 用户态（U）



CPU大部分时间运行在低权限模式，处理中断异常时会将控制权交给更高的权限模式。  

特权指令：很少，基本上通过【控制状态寄存器】（CSR, Constrol State Register）来实现。  CSR有： mtvec, mepc, mcause, mie(目前能处理的中断), mip(正在处理的中断), mtval, mscratch,mstatus  

mstatus.MIE 置1时才会产生中断，0会屏蔽所有中断  



硬件线程hart  （hardware thread）



同步异常，如ecall的环境调用异常（可以实现应用程序通过系统调用从OS中获得服务）、ebreak的断点异常（可以实现断点调试）、ID发现的非法指令异常、EX或者MEM发现的非对齐地址异常

**异步异常，即中断**，中断源（来源）有软件中断、时钟中断、外部中断  



M模式指定U模式可以访问的内存地址  

S模式进行页内存管理，支持虚拟内存  

- satp 寄存器（Supervisor Address Translation ＆ Protection）进行监管者地址转换和保护 ，刚进入S模式时会将0写入satp



ASID（Address Space Identifier）地址空间标识符，用于降低上下文切换开销  



系统编程的两大主题：异常和中断处理、内存管理  



# IO



输入输出方式：

1. 程序直接控制，通过轮询。【特点】成本低、效率低、严重占用CPU资源  
2. 程序中断方式，CPU和外设并行工作，外设发起请求，CPU收到中断，停止之前的程序进行相应。【特点】提高CPU效率，可以同时管理多个外设，但是对CPU干扰较大，适用于传输速度不高、传输量不大的情况。  



## 中断

中断优先级决定了响应的顺序



中断源设备设置中断触发器  



处理过程：

- 关中断 -> 保存断点 -> 判断中断源、转中断服务 -> 开中断 -> 执行中断服务程序 -> 关中断 -> 恢复断点 -> 开中断 -> 返回断点



## DMA

直接存储访问（DMA, Direct Memory Access） ：用于高速外设和主存之间【成组传送】数据  

传送开始前＆结束后都通过程序 or 中断方式使CPU对DMA进行预处理和后处理，但传送时CPU是不被影响的，可以继续执行主程序。  数据传输过程由DMA自行控制  

特点：与设备**一对一服务**（多DMA控制器同时工作可能发生冲突），对CPU打扰适中，无法适用大量高速设备的管理  



DMA工作方式

- 独占总线方式
- 周期窃取方式  



## 通道控制方式

一对多的连接关系 ，适应不同速度、不同种类的外部设备  



## 外围处理机

...



# 总线bus

控制、地址、数据总线



双总线：处理器-主存总线、输入/输出总线

三总线：北桥和南桥之间还有一个主板总线（backplane bus，比如PCI）

北桥是快的，cpu 主存那些。南桥是慢的，io那些



总线事务：发起命令，传输数据 。主设备：发起  ，从设备：响应  

一群主设备都需要发起命令时，通过仲裁获得总线使用权  

总线仲裁方式  ：

1. 集中仲裁
   - 菊链仲裁（简单但可能不公平）
   - 集中平行仲裁
2. 分布仲裁



总线工作方式 ：

同步总线，根据时钟信号 => 为防止信号扭曲，总线距离需要比较短  

异步总线，距离可以长，使用握手协议  



增加总线带宽的方式：  

- 增加总线的宽度  
- 分离地址总线和数据总线  
- 采用成组传送方式   



PCI总线：了解一下。集中仲裁方式  




# device 接口电路和外部设备  

接口：总线和外部设备的连接，基本功能有

- 使主机能根据设备编号找到外设
- 使主机能控制设备并与之通信
- 提供主机和设备之间的数据缓冲机制



USB采用同步传输方式，因此USB帧还设置有同步帧，用于同步。  



# 杂

L1 cache和CPU在一起，L2 L3和主存在一起



不一定CPI越小性能越好，需要综合考虑主频、不同指令集对同一程序产生的指令条数等因素。  (比如我有一个指令集，CPI很小，但是写出来的程序耗费的指令巨多)



# TODO

分支预测

cache

虚存等后面的课件

数电有关的，比如触发器



2020计原复习笔记 写得挺好的（这里面还有一个虚存的例子）

github cracker的hw里面有以往作业题，做一做

2019有完整题 2020有题 2021有题 复习题



把jal、 jalr等不熟悉指令的作用写到cheatsheet里面

callee caller saved的寄存器

